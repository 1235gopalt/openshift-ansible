---
# It's important that we don't explicitly pull this image here.  Otherwise we
# could result in upgrading a preinstalled environment.  We'll have to set
# openshift_image_tag correctly for upgrades.

# Determine openshift_version if none is set for this host, or if a generic "3.2"
# is set, determine the more specific version number by either installing the latest
# rpm, or pulling the v3.2 container and checking the resulting versions.

- set_fact:
    is_containerized: "{{ openshift.common.is_containerized | default(False) | bool }}"

- debug: var=openshift_version
- debug: var=openshift_release
- debug: var=openshift_pkg_version
- debug: var=openshift_image_tag

# RPM openshift_version setup:
# TODO: support openshift_release here:
- name: Determine rpm version to configure when openshift_pkg_version specified
  set_fact:
    # Expects a leading "-" in inventory, strip it off here, and ignore a trailing release,
    # openshift_version should always just be "3.2" or "3.2.0.44"
    openshift_version: "{{ openshift_pkg_version[1:].split('-')[0] }}"
  when: not is_containerized | bool and openshift_pkg_version is defined and openshift_version is not defined

- name: Use openshift.common.version fact as version to configure if already installed
  set_fact:
    openshift_version: "{{ openshift.common.version }}"
  when: openshift.common.version is defined and openshift_version is not defined

- name: Lookup latest OpenShift rpm version if none specified
  action: "{{ ansible_pkg_mgr }} name={{ openshift.common.service_type }}{{ openshift_version | default('') | oo_image_tag_to_rpm_version(include_dash=True) }} state=present"
  when: not is_containerized | bool and openshift_version is not defined

- name: Reload facts to pick up version
  openshift_facts:
  when: not is_containerized | bool and openshift_version is not defined

- set_fact:
    openshift_version: "{{ openshift.common.version }}"
  when: not is_containerized | bool and openshift_version is not defined


# Containerized openshift_version setup:
- name: Determine version to configure if containerized and release specified
  set_fact:
    openshift_version: "{{ openshift_release }}"
  when: is_containerized | bool and openshift_release is defined and openshift_version is not defined

- name: Determine container version to configure when openshift_image_tag specified
  set_fact:
    openshift_version: "{{ openshift_image_tag.split('v',1)[1] }}"
  when: is_containerized | bool and openshift_image_tag is defined and openshift_version is not defined

- name: Lookup latest containerized OpenShift version if none specified
  command: >
    docker run --rm {{ openshift.common.cli_image }}:latest version
  register: cli_image_version
  when: is_containerized | bool and openshift_version is not defined

- debug: var=cli_image_version

- set_fact:
    openshift_version: "{{ cli_image_version.stdout_lines[0].split(' ')[1].split('-')[0:2][1:] | join('-') if openshift.common.deployment_type == 'origin' else cli_image_version.stdout_lines[0].split(' ')[1].split('-')[0][1:] }}"
  when: is_containerized | bool and openshift_version is not defined

# If we got an openshift_version like "3.2", lookup the latest 3.2 container version
# and use that value instead.
- name: Lookup specific OpenShift version if generic release specified
  command: >
    docker run --rm {{ openshift.common.cli_image }}:v{{ openshift_version }} version
  register: cli_image_version
  when: is_containerized | bool and openshift_version is defined and openshift_version.split('.') | length == 2

- set_fact:
    openshift_version: "{{ cli_image_version.stdout_lines[0].split(' ')[1].split('-')[0:2][1:] | join('-') if openshift.common.deployment_type == 'origin' else cli_image_version.stdout_lines[0].split(' ')[1].split('-')[0][1:] }}"
  when: is_containerized | bool and openshift_version is defined and openshift_version.split('.') | length == 2


- debug: var=openshift_version

